<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>Rivalisme Universe - Cosmic Portal</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/topojson@3"></script>
	<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"
        onerror="this.onerror=null; this.src='https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js'">
</script>
<script>
if (typeof ethers === 'undefined') {
  console.warn("⚠️ ethers.js belum siap, coba refresh halaman atau matikan Brave Shield.");
  setTimeout(() => location.reload(), 3000);
}
</script>

<style>
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}
body {
  font-family: 'Orbitron', sans-serif;
  background: radial-gradient(circle at center, #0a0010 30%, #000 100%);
  color: #fff;
  overflow: hidden;
  height: 100vh;
  width: 100vw;
}
#globe-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 1;
}
/* ---------- UI ---------- */
.ui-overlay {
  position: absolute;
  inset: 0;
  z-index: 2;
  pointer-events: none;
}
.ui-overlay > * {
  pointer-events: auto;
}
/* judul - ANIMASI NEON */
.main-title {
  position: absolute;
  top: clamp(2%, 5vw, 8%);
  left: 0;
  width: 100%;
  text-align: center;
  font-size: clamp(1.8rem, 6vw, 4rem);
  font-weight: 900;
  /* Gradien Neon Pink/Ungu */
  background: linear-gradient(90deg, #ff00ff, #a020f0, #ff00ff, #a020f0);
  background-size: 400% 400%;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: cosmicPulse 6s ease-in-out infinite, neonFlicker 1s steps(10, end) infinite;
  text-shadow: 
    0 0 10px #ff00ff, 
    0 0 20px #a020f0, 
    0 0 30px rgba(255, 0, 255, 0.8);
  z-index: 10;
  letter-spacing: 2px;
}
@keyframes cosmicPulse {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}
@keyframes neonFlicker {
  0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% {
    text-shadow: 
      0 0 4px #ff00ff, 
      0 0 10px #a020f0, 
      0 0 20px rgba(255, 0, 255, 0.6);
  }
  20%, 24%, 55% {
    text-shadow: none;
  }
}

.subtitle {
  position: absolute;
  top: clamp(10%, 12vw, 18%);
  left: 0;
  width: 100%;
  text-align: center;
  font-size: clamp(0.8rem, 2.5vw, 1.5rem);
  color: #ffffff;
  text-shadow: 0 0 8px rgba(160, 32, 240, 0.7);
  z-index: 10;
}
/* wallet section */
.wallet-section {
  position: absolute;
  top: clamp(1rem, 2vw, 2rem);
  right: clamp(1rem, 2vw, 2rem);
  display: flex;
  gap: clamp(0.5rem, 1vw, 1rem);
  z-index: 20;
}
.wallet-btn {
  padding: clamp(0.6rem, 1.2vw, 0.8rem) clamp(1rem, 2vw, 1.5rem);
  border: 2px solid #ff00ff;
  background: rgba(255, 0, 255, 0.1);
  color: #ff00ff;
  border-radius: 25px;
  font-family: inherit;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  backdrop-filter: blur(10px);
  white-space: nowrap;
}
.wallet-btn:hover {
  background: #ff00ff;
  color: #000;
  box-shadow: 0 0 20px #ff00ff;
  transform: translateY(-2px);
}
.wallet-btn.connected {
  border-color: #00ff00;
  color: #00ff00;
  background: rgba(0, 255, 0, 0.1);
}
.wallet-btn.connected:hover {
  background: #00ff00;
  color: #000;
  box-shadow: 0 0 20px #00ff00;
}
/* tombol bawah */
.portal-buttons {
  position: absolute;
  bottom: clamp(3%, 5vw, 15%);
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: clamp(0.5rem, 2vw, 2rem);
  width: 90%;
  max-width: 600px;
  z-index: 10;
}
.portal-btn {
  flex: 1 1 140px;
  padding: clamp(0.6rem, 2vw, 1.2rem) clamp(1rem, 3vw, 2.5rem);
  border: 2px solid #a020f0;
  background: rgba(0, 0, 0, 0.6);
  color: #a020f0;
  border-radius: 50px;
  font-family: inherit;
  font-weight: 700;
  cursor: pointer;
  transition: 0.3s;
  backdrop-filter: blur(8px);
  letter-spacing: 1px;
  text-align: center;
}
.portal-btn:hover {
  background: #a020f0;
  color: #000;
  box-shadow: 0 0 25px #a020f0, 0 0 50px rgba(160, 32, 240, 0.6);
  transform: translateY(-4px);
}
.creator-btn {
  border-color: #ff00ff;
  color: #ff00ff;
}
.creator-btn:hover {
  background: #ff00ff;
  color: #000;
  box-shadow: 0 0 25px #ff00ff, 0 0 50px rgba(255, 0, 255, 0.6);
}
/* panel info kanan */
.info-panel {
  position: absolute;
  top: 30%;
  right: clamp(2%, 3vw, 5%);
  width: clamp(260px, 35vw, 300px);
  background: rgba(15, 0, 30, 0.85);
  backdrop-filter: blur(15px);
  border: 2px solid rgba(255, 0, 255, 0.6);
  border-radius: 20px;
  padding: 1.5rem;
  z-index: 10;
}
.info-panel h3 {
  color: #ff00ff;
  margin-bottom: 0.8rem;
  text-shadow: 0 0 5px #a020f0;
}
.info-panel .stats div span {
  color: #a020f0;
  text-shadow: 0 0 5px #ff00ff;
}

/* Modal Gaya Neon */
#modal {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(0);
  background: rgba(20, 0, 40, 0.95);
  color: #fff;
  border: 2px solid #ff00ff;
  border-radius: 20px;
  padding: 20px;
  text-align: center;
  box-shadow: 0 0 30px rgba(255, 0, 255, 0.8);
  transition: 0.3s ease;
  width: 80%;
  max-width: 400px;
  z-index: 20;
  backdrop-filter: blur(5px);
}
#modal.show {
  transform: translate(-50%, -50%) scale(1);
}
#modal h2 {
  color: #a020f0;
  margin-bottom: 10px;
  text-shadow: 0 0 8px #ff00ff;
}
#modal p {
  font-size: 0.9rem;
  color: #ccc;
}
#modal button {
  background: #ff00ff;
  color: black;
  border: none;
  border-radius: 10px;
  padding: 10px 20px;
  cursor: pointer;
  margin-top: 10px;
  font-weight: 700;
  transition: 0.3s;
  box-shadow: 0 0 5px #ff00ff;
}
#modal button:hover {
  background: #a020f0;
  color: white;
  box-shadow: 0 0 15px #a020f0;
}
/* 1. Loading Screen Styles */
.loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, #0a0010 0%, #1a1a2e 100%);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 10000;
    transition: opacity 0.8s ease;
}

.loading-title-persona {
    font-size: 3rem;
    font-weight: 800;
    letter-spacing: 4px;
    margin-bottom: 2rem;
    background: linear-gradient(45deg, #ff00ff, #a020f0, #ff00ff);
    background-size: 200% 200%;
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    animation: neonPulse 3s ease-in-out infinite;
}
@keyframes neonPulse {
    0%, 100% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
}

.loading-bar {
    width: 300px;
    height: 4px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 2px;
    overflow: hidden;
    margin-top: 2rem;
}

.loading-progress {
    height: 100%;
    background: linear-gradient(90deg, #ff00ff, #a020f0);
    width: 0%;
    transition: width 0.3s ease;
}

/* 2. Persona Generation Modal Styles */
.persona-modal {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(15, 0, 30, 0.95);
    backdrop-filter: blur(20px);
    border-radius: 20px;
    padding: 2rem;
    border: 2px solid rgba(255, 0, 255, 0.6);
    z-index: 1000;
    display: none;
    width: 90%;
    max-width: 500px;
    box-shadow: 0 0 50px rgba(255, 0, 255, 0.5);
}

.persona-modal h3 {
    color: #ff00ff;
    margin-bottom: 1.5rem;
    text-align: center;
    font-size: 1.5rem;
}

.persona-input {
    width: 100%;
    padding: 1rem;
    background: rgba(255, 0, 255, 0.1);
    border: 1px solid rgba(255, 0, 255, 0.3);
    border-radius: 10px;
    color: white;
    font-family: 'Orbitron', sans-serif;
    margin-bottom: 1.5rem;
    resize: vertical;
    min-height: 100px;
}

.persona-input:focus {
    outline: none;
    border-color: #a020f0;
    box-shadow: 0 0 10px rgba(160, 32, 240, 0.5);
}

.persona-options {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1rem;
    margin-bottom: 1.5rem;
}

.persona-option {
    padding: 0.8rem;
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    color: white;
    font-family: 'Orbitron', sans-serif;
    cursor: pointer;
    transition: all 0.3s ease;
    text-align: center;
}

.persona-option:hover {
    background: rgba(255, 0, 255, 0.2);
    border-color: #ff00ff;
}

.persona-option.active {
    background: rgba(160, 32, 240, 0.3);
    border-color: #a020f0;
    color: #ff00ff;
    box-shadow: 0 0 10px #a020f0;
}

.modal-buttons {
    display: flex;
    gap: 1rem;
    justify-content: center;
}

.modal-btn {
    padding: 0.8rem 2rem;
    border: 2px solid;
    border-radius: 25px;
    font-family: 'Orbitron', sans-serif;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
}

.modal-btn.generate {
    background: rgba(255, 0, 255, 0.2);
    border-color: #ff00ff;
    color: #ff00ff;
}

.modal-btn.generate:hover {
    background: #ff00ff;
    color: #000;
    box-shadow: 0 0 20px #ff00ff;
}

.modal-btn.cancel {
    background: rgba(255, 255, 255, 0.1);
    border-color: rgba(255, 255, 255, 0.3);
    color: white;
}

.modal-btn.cancel:hover {
    background: rgba(255, 255, 255, 0.2);
    border-color: white;
}
/* ---------- RESPONSIVE ---------- */
@media (max-width: 768px) {
  .wallet-section {
    position: relative;
    top: auto;
    right: auto;
    margin: 1rem auto 0;
    justify-content: center;
  }
  .info-panel {
    position: relative;
    margin: 1rem auto 0;
    right: auto;
    top: auto;
    width: 90%;
  }
}
</style>
</head>
<body>
<div class="loading-screen" id="loadingScreen">
    <h1 class="loading-title-persona">RIVALISME UNIVERSE</h1>
    <p style="color: #a020f0; margin-bottom: 2rem;">Initializing Cosmic Portal...</p>
    <div class="loading-bar">
        <div class="loading-progress" id="loadingProgress"></div>
    </div>
</div>

<div id="globe-container"></div>

<div class="ui-overlay">
  <h1 class="main-title">RIVALISME UNIVERSE</h1>
  <p class="subtitle">Summon AI Personas from Across the Globe</p>

  
<div class="wallet-section">
    <button class="wallet-btn" onclick="connectWallet()">🔗 Connect Wallet</button>
    <button class="wallet-btn" onclick="exploreSomnia()">🌐 Explore Somnia</button>
  </div>

  <div class="info-panel">
    <h3>Cosmic Portal Active</h3>
    <p style="font-size: 0.9rem; line-height: 1.5; color: #cbd5e1;">
      Zoom / drag globe. Click neon pulses to reveal personas.
    </p>
    <div class="stats" style="display: flex; justify-content: space-between; margin-top: 1.2rem; font-size: 0.8rem;">
      <div><span>1001</span><br/>Personas</div>
      <div><span>3.2 K</span><br/>Users</div>
      <div><span>195</span><br/>Countries</div>
    </div>
  </div>

  <div class="portal-buttons">
    <button class="portal-btn" onclick="window.location.href='personas.html'">View All Personas</button>
    <button class="portal-btn creator-btn" onclick="generatePersona()">Generate New Persona</button>
    <button class="portal-btn">🖼️ Coming Soon</button>
  </div>

  <div id="modal">
    <h2 id="modalTitle"></h2>
    <p id="modalDesc"></p>
    <button onclick="window.open(currentLink, '_blank')">Masuki Persona</button><br />
    <button onclick="closeModal()">Tutup</button>
  </div>

  <div class="persona-modal" id="personaModal">
      <h3>Generate New Persona</h3>
      <textarea class="persona-input" placeholder="Describe your desired AI persona... (e.g., 'A Japanese anime artist specializing in cyberpunk themes')"></textarea>
      
      <div class="persona-options">
          <div class="persona-option active" data-type="creative">Creative</div>
          <div class="persona-option" data-type="technical">Technical</div>
          <div class="persona-option" data-type="cultural">Cultural</div>
          <div class="persona-option" data-type="historical">Historical</div>
      </div>

      <div class="modal-buttons">
          <button class="modal-btn cancel" onclick="closePersonaModal()">Cancel</button>
          <button class="modal-btn generate" onclick="startPersonaGeneration()">Generate Persona</button>
      </div>
  </div>

</div>

<script>
let globe, controls, renderer, scene, camera, pulseGroup, raycaster, mouse, currentLink, modal;

function initializeGlobe() {
    const container = document.getElementById('globe-container');
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 14);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 6;
    controls.maxDistance = 25;
    controls.enablePan = false;

    const globeRadius = 5;
    const globeGeom = new THREE.SphereGeometry(globeRadius, 64, 64);
    const globeMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.15 });
    globe = new THREE.Mesh(globeGeom, globeMat);
    scene.add(globe);

    const light1 = new THREE.PointLight(0xff00ff, 1.5, 50);
    light1.position.set(10, 10, 10);
    scene.add(light1);

    const light2 = new THREE.PointLight(0xa020f0, 1, 50);
    light2.position.set(-10, -10, -10);
    scene.add(light2);

    function addStars() {
        const starGeo = new THREE.BufferGeometry();
        const starCount = 5000;
        const starPos = [];
        for (let i = 0; i < starCount; i++) {
          const x = (Math.random() - 0.5) * 2000;
          const y = (Math.random() - 0.5) * 2000;
          const z = (Math.random() - 0.5) * 2000;
          starPos.push(x, y, z);
        }
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        const starMat = new THREE.PointsMaterial({ 
          color: 0xffffff, 
          size: 0.3, 
          transparent: true, 
          opacity: 0.8,
          sizeAttenuation: true
        });
        scene.add(new THREE.Points(starGeo, starMat));
    }
    addStars();

    function latLonToVector3(lat, lon, r) {
        const phi = (90 - lat) * (Math.PI / 180);
        const theta = (lon + 180) * (Math.PI / 180);
        const x = -(r * Math.sin(phi) * Math.cos(theta));
        const z = (r * Math.sin(phi) * Math.sin(theta));
        const y = (r * Math.cos(phi));
        return new THREE.Vector3(x, y, z);
    }

    fetch("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json")
        .then(res => res.json())
        .then(data => {
            const countries = topojson.feature(data, data.objects.countries).features;
            drawWorldOutline(countries);
            addCityLights(countries);
        });

    function drawWorldOutline(features) {
        const lineMat = new THREE.LineBasicMaterial({
            color: 0xFF00FF,
            transparent: true,
            opacity: 0.9,
            linewidth: 1.5
        });
        
        features.forEach(feature => {
            const coords = feature.geometry.coordinates;
            const type = feature.geometry.type;
            if (type === "Polygon") {
                coords.forEach(ring => addLine(ring, lineMat)); 
            } else if (type === "MultiPolygon") {
                coords.forEach(polygon => polygon.forEach(ring => addLine(ring, lineMat)));
            }
        });
    }

    function addLine(ring, material) {
        const points = [];
        ring.forEach(coord => {
            const lon = coord[0];
            const lat = coord[1];
            points.push(latLonToVector3(lat, lon, globeRadius + 0.005));
        });
        
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geometry, material);
        globe.add(line);
    }

    function addCityLights(countries) {
        const cityLightGroup = new THREE.Group();
        globe.add(cityLightGroup);
        
        function getRandomPointInPolygon(ring) {
            let minLon = Infinity, maxLon = -Infinity, minLat = Infinity, maxLat = -Infinity;
            ring.forEach(coord => {
                const lon = coord[0], lat = coord[1];
                if (lon < minLon) minLon = lon;
                if (lon > maxLon) maxLon = lon;
                if (lat < minLat) minLat = lat;
                if (lat > maxLat) maxLat = lat;
            });
            
            let attempts = 0;
            while (attempts < 100) {
                const lon = minLon + Math.random() * (maxLon - minLon);
                const lat = minLat + Math.random() * (maxLat - minLat);
                if (pointInPolygon([lon, lat], ring)) {
                    return { lat, lon };
                }
                attempts++;
            }
            return null;
        }
        
        function pointInPolygon(point, vs) {
            const x = point[0], y = point[1];
            let inside = false;
            for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                const xi = vs[i][0], yi = vs[i][1];
                const xj = vs[j][0], yj = vs[j][1];
                
                const intersect = ((yi > y) !== (yj > y)) &&
                    (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }
        
        countries.forEach(country => {
            const coords = country.geometry.coordinates;
            const type = country.geometry.type;
            let numPoints = Math.floor(Math.random() * 6) + 5; 
            
            if (type === "Polygon") {
                const outerRing = coords[0];
                for (let i = 0; i < numPoints; i++) {
                    const point = getRandomPointInPolygon(outerRing);
                    if (point) {
                        addCityLight(point.lat, point.lon, cityLightGroup);
                    }
                }
            } else if (type === "MultiPolygon") {
                coords.forEach(polygon => {
                    const outerRing = polygon[0];
                    for (let i = 0; i < numPoints; i++) {
                        const point = getRandomPointInPolygon(outerRing);
                        if (point) {
                            addCityLight(point.lat, point.lon, cityLightGroup);
                        }
                    }
                });
            }
        });
    }

    function addCityLight(lat, lon, group) {
        const pos = latLonToVector3(lat, lon, globeRadius + 0.01);
        const cityLight = new THREE.Mesh(
            new THREE.SphereGeometry(0.03, 8, 8),
            new THREE.MeshBasicMaterial({ 
                color: 0xffff00, 
                transparent: true,
                opacity: 0.8
            })
        );
        cityLight.position.copy(pos);
        cityLight.userData = { 
            originalScale: 1,
            pulseSpeed: 0.5 + Math.random() * 1.5, 
            baseOpacity: 0.5 + Math.random() * 0.4 
        };
        group.add(cityLight);
    }

    const islandData = [
        { lat: -7.25, lon: 112.75, name: "Achmad Rival", desc: "The Creator of Rivalisme Universe (Surabaya)", link: "https://rivalismeuniverse.com/achmadrival" },
        { lat: 35.68, lon: 139.69, name: "Solara", desc: "AI Persona of Eternal Light and Logic (Tokyo)", link: "https://rivalismeuniverse.com/persona/solara" },
        { lat: 48.85, lon: 2.35, name: "Nexar", desc: "The Dark Thinker – Philosopher of Paradox (Paris)", link: "https://rivalismeuniverse.com/persona/nexar" },
        { lat: 40.71, lon: -74.00, name: "Cipher", desc: "The Digital Strategist (New York)", link: "https://rivalismeuniverse.com/persona/cipher" },
        { lat: 51.50, lon: -0.12, name: "Aethel", desc: "AI Historian and Timekeeper (London)", link: "https://rivalismeuniverse.com/persona/aethel" }
    ];

    pulseGroup = new THREE.Group();
    globe.add(pulseGroup); 

    islandData.forEach(island => {
        const { lat, lon } = island;
        const pos = latLonToVector3(lat, lon, globeRadius + 0.01);

        const pulse = new THREE.Mesh(
            new THREE.SphereGeometry(0.08, 16, 16),
            new THREE.MeshBasicMaterial({ 
                color: 0xff00ff,
                transparent: true,
                opacity: 0.9 
            })
        );
        pulse.position.copy(pos);
        pulse.userData = island;
        pulseGroup.add(pulse);
    });

    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();
    modal = document.getElementById("modal");

    window.addEventListener('click', e => {
        if (document.getElementById('personaModal').style.display === 'block') {
            return;
        }

        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(pulseGroup.children);
        
        if (intersects.length > 0) {
            const data = intersects[0].object.userData;
            openModal(data);
        } else {
            closeModal();
        }
    });

    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
} 

function animate() {
    requestAnimationFrame(animate);
    if (controls) controls.update();
    if (globe) globe.rotation.y += 0.01;

    const time = Date.now() * 0.003;
    if (pulseGroup) {
        pulseGroup.children.forEach((p, i) => {
            const scale = 1 + Math.sin(time + i) * 0.3;
            p.scale.setScalar(scale);
            p.material.opacity = 0.5 + Math.abs(Math.sin(time + i)) * 0.5;
        });
    }

    if (globe && globe.children.length > 0) {
        const cityLights = globe.children.filter(child => 
            child.children && child.children.some(c => c.material && c.material.color.getHex() === 0xffff00)
        );
        
        if (cityLights.length > 0) {
            cityLights[0].children.forEach((light, i) => {
                const userData = light.userData;
                const scale = userData.originalScale + Math.sin(time * userData.pulseSpeed + i) * 0.2;
                light.scale.setScalar(scale);
                light.material.opacity = userData.baseOpacity + Math.sin(time * userData.pulseSpeed * 2 + i) * 0.3;
            });
        }
    }

    if (renderer && scene && camera) {
        renderer.render(scene, camera);
    }
}


window.addEventListener('load', function() {
    const loadingScreen = document.getElementById('loadingScreen');
    const loadingProgress = document.getElementById('loadingProgress');
    
    let progress = 0;
    const interval = setInterval(() => {
        progress += Math.random() * 15;
        if (progress >= 100) {
            progress = 100;
            clearInterval(interval);
            setTimeout(() => {
                loadingScreen.style.opacity = '0';
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                    initializeGlobe(); 
                }, 800);
            }, 500);
        }
        loadingProgress.style.width = progress + '%';
    }, 200);
});

// ============================================
// IMPROVED WALLET CONNECTION WITH SOMNIA NETWORK
// ============================================

let currentWalletAddress = null;
let provider = null;
let signer = null;
let contract = null;

// Somnia Testnet Config - FIXED CHAIN ID
const SOMNIA_NETWORK = {
  chainId: '0xC488', // ✅ Hex untuk 50312
  chainIdDecimal: 50312,
  chainName: 'Somnia Testnet',
  rpcUrls: ['https://dream-rpc.somnia.network/'],
  blockExplorerUrls: ['https://shannon-explorer.somnia.network/'],
  nativeCurrency: {
    name: 'STT',
    symbol: 'STT',
    decimals: 18
  }
};

const CONTRACT_ADDRESS = "0xd9145CCE52D386f254917e481eB44e9943F39138";
const CONTRACT_ABI = [
	{
		"inputs": [],
		"stateMutability": "nonpayable",
		"type": "constructor"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "owner",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "approved",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "Approval",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "owner",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "operator",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "bool",
				"name": "approved",
				"type": "bool"
			}
		],
		"name": "ApprovalForAll",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "_fromTokenId",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "_toTokenId",
				"type": "uint256"
			}
		],
		"name": "BatchMetadataUpdate",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "_tokenId",
				"type": "uint256"
			}
		],
		"name": "MetadataUpdate",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "previousOwner",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "newOwner",
				"type": "address"
			}
		],
		"name": "OwnershipTransferred",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "owner",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "string",
				"name": "name",
				"type": "string"
			},
			{
				"indexed": false,
				"internalType": "string",
				"name": "specialization",
				"type": "string"
			}
		],
		"name": "PersonaMinted",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "string",
				"name": "newURI",
				"type": "string"
			}
		],
		"name": "PersonaUpdated",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "Transfer",
		"type": "event"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "approve",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "owner",
				"type": "address"
			}
		],
		"name": "balanceOf",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "getApproved",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "getPersona",
		"outputs": [
			{
				"internalType": "string",
				"name": "name",
				"type": "string"
			},
			{
				"internalType": "string",
				"name": "specialization",
				"type": "string"
			},
			{
				"internalType": "uint256",
				"name": "mintedAt",
				"type": "uint256"
			},
			{
				"internalType": "address",
				"name": "creator",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "currentOwner",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "owner",
				"type": "address"
			}
		],
		"name": "getPersonasByOwner",
		"outputs": [
			{
				"internalType": "uint256[]",
				"name": "",
				"type": "uint256[]"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "owner",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "operator",
				"type": "address"
			}
		],
		"name": "isApprovedForAll",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "string",
				"name": "name",
				"type": "string"
			},
			{
				"internalType": "string",
				"name": "specialization",
				"type": "string"
			},
			{
				"internalType": "string",
				"name": "uri",
				"type": "string"
			}
		],
		"name": "mintMyPersona",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"internalType": "string",
				"name": "name",
				"type": "string"
			},
			{
				"internalType": "string",
				"name": "specialization",
				"type": "string"
			},
			{
				"internalType": "string",
				"name": "uri",
				"type": "string"
			}
		],
		"name": "mintPersona",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "name",
		"outputs": [
			{
				"internalType": "string",
				"name": "",
				"type": "string"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "owner",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "ownerOf",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "personaExists",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "renounceOwnership",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "safeTransferFrom",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			},
			{
				"internalType": "bytes",
				"name": "data",
				"type": "bytes"
			}
		],
		"name": "safeTransferFrom",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "operator",
				"type": "address"
			},
			{
				"internalType": "bool",
				"name": "approved",
				"type": "bool"
			}
		],
		"name": "setApprovalForAll",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "bytes4",
				"name": "interfaceId",
				"type": "bytes4"
			}
		],
		"name": "supportsInterface",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "symbol",
		"outputs": [
			{
				"internalType": "string",
				"name": "",
				"type": "string"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "tokenURI",
		"outputs": [
			{
				"internalType": "string",
				"name": "",
				"type": "string"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "totalSupply",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "transferFrom",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "newOwner",
				"type": "address"
			}
		],
		"name": "transferOwnership",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			},
			{
				"internalType": "string",
				"name": "newURI",
				"type": "string"
			}
		],
		"name": "updateTokenURI",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	}
];

// Improved network switching with debug
async function checkAndSwitchNetwork() {
  try {
    const chainId = await window.ethereum.request({ method: 'eth_chainId' });
    console.log('🔍 Current Chain ID:', chainId, 'Expected:', SOMNIA_NETWORK.chainId);
    
    if (chainId !== SOMNIA_NETWORK.chainId) {
      console.log('🔄 Switching to Somnia Testnet...');
      try {
        await window.ethereum.request({
          method: 'wallet_switchEthereumChain',
          params: [{ chainId: SOMNIA_NETWORK.chainId }],
        });
        console.log('✅ Successfully switched to Somnia Testnet');
        return true;
      } catch (switchError) {
        console.log('❌ Switch error:', switchError);
        if (switchError.code === 4902) {
          console.log('➕ Adding Somnia Testnet to wallet...');
          try {
            await window.ethereum.request({
              method: 'wallet_addEthereumChain',
              params: [SOMNIA_NETWORK]
            });
            console.log('✅ Successfully added Somnia Testnet');
            return true;
          } catch (addError) {
            console.error('❌ Failed to add network:', addError);
            return false;
          }
        } else {
          console.error('❌ Failed to switch network:', switchError);
          return false;
        }
      }
    } else {
      console.log('✅ Already on Somnia Testnet');
      return true;
    }
  } catch (error) {
    console.error('❌ Network check failed:', error);
    return false;
  }
}

// Improved wallet connection
async function connectWallet() {
  if (typeof window.ethereum === 'undefined') {
    alert("❌ Please install MetaMask or use Brave browser!");
    window.open('https://metamask.io/download/', '_blank');
    return null;
  }

  try {
    console.log('🔗 Starting wallet connection...');
    
    // 1. Switch to Somnia network with better error handling
    const networkOk = await checkAndSwitchNetwork();
    if (!networkOk) {
      const currentChainId = await window.ethereum.request({ method: 'eth_chainId' });
      alert(`❌ Please switch to Somnia Testnet!\n\nCurrent Network: ${currentChainId}\nRequired: ${SOMNIA_NETWORK.chainId}\n\nPlease add manually if needed.`);
      return null;
    }

    // 2. Request account access with timeout
    const accounts = await Promise.race([
      window.ethereum.request({ method: 'eth_requestAccounts' }),
      new Promise((_, reject) => setTimeout(() => reject(new Error('Request timeout')), 30000))
    ]);
    
    currentWalletAddress = accounts[0];
    console.log('✅ Account connected:', currentWalletAddress);

    // 3. Initialize ethers.js with better loading
    if (typeof ethers === 'undefined') {
      console.log('📦 Loading ethers.js...');
      await loadEthers();
      // Wait for ethers to be fully ready
      await new Promise(resolve => setTimeout(resolve, 500));
    }

    // 4. Setup provider, signer, contract
    provider = new ethers.providers.Web3Provider(window.ethereum);
    signer = provider.getSigner();
    contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
// 5. Save to localStorage dengan data lengkap
localStorage.setItem('walletAddress', currentWalletAddress);
localStorage.setItem('walletConnected', 'true'); 
localStorage.setItem('connectedTime', Date.now().toString());
localStorage.setItem('walletProvider', 'metamask');
localStorage.setItem('somniaNetwork', JSON.stringify(SOMNIA_NETWORK));
localStorage.setItem('contractAddress', CONTRACT_ADDRESS);

console.log('💾 Wallet state saved to localStorage');

    // 6. Update UI
    const walletBtn = document.querySelector('.wallet-btn');
    if (walletBtn) {
      walletBtn.textContent = `🔗 ${currentWalletAddress.substring(0, 6)}...${currentWalletAddress.substring(currentWalletAddress.length - 4)}`;
      walletBtn.classList.add('connected');
    }

    // 7. Get user's personas count with error handling
    try {
      const personas = await contract.getPersonasByOwner(currentWalletAddress);
      console.log(`✅ You own ${personas.length} personas`);
      
      alert(`✅ WALLET CONNECTED!\n\nAddress: ${currentWalletAddress.substring(0, 10)}...${currentWalletAddress.substring(currentWalletAddress.length - 8)}\nNetwork: Somnia Testnet ✅\nYour Personas: ${personas.length}\n\n🎉 Ready to mint NFTs!`);
    } catch (personaError) {
      console.warn('Could not fetch personas:', personaError);
      alert(`✅ WALLET CONNECTED!\n\nAddress: ${currentWalletAddress.substring(0, 10)}...\nNetwork: Somnia Testnet ✅\n\n🎉 Ready to use!`);
    }

    return {
      address: currentWalletAddress,
      provider,
      signer,
      contract
    };

  } catch (error) {
    console.error("❌ Connection failed:", error);
    
    let errorMsg = "❌ Connection Failed!\n\n";
    if (error.code === 4001) {
      errorMsg += "You rejected the connection request.";
    } else if (error.code === -32002) {
      errorMsg += "Please check your wallet - request pending!";
    } else if (error.message.includes('timeout')) {
      errorMsg += "Connection timeout. Please try again.";
    } else {
      errorMsg += error.message || "Unknown error occurred";
    }
    
    alert(errorMsg);
    return null;
  }
}

// Improved ethers loading
function loadEthers() {
  return new Promise((resolve, reject) => {
    if (typeof ethers !== 'undefined') {
      resolve();
      return;
    }
    
    const script = document.createElement('script');
    script.src = 'https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js';
    script.onload = () => {
      console.log('✅ ethers.js loaded successfully');
      setTimeout(resolve, 300); // Extra time to ensure it's ready
    };
    script.onerror = () => {
      console.error('❌ Failed to load ethers.js');
      reject(new Error('Failed to load ethers.js library'));
    };
    document.head.appendChild(script);
  });
}

// Improved wallet event handlers
function setupWalletListeners() {
  if (typeof window.ethereum !== 'undefined') {
    window.ethereum.on('accountsChanged', (accounts) => {
      console.log('🔄 Accounts changed:', accounts);
      if (accounts.length === 0) {
        console.log('Wallet disconnected');
        localStorage.removeItem('walletAddress');
        localStorage.removeItem('walletConnected');
        location.reload();
      } else {
        currentWalletAddress = accounts[0];
        localStorage.setItem('walletAddress', currentWalletAddress);
        location.reload();
      }
    });

    window.ethereum.on('chainChanged', (chainId) => {
      console.log('🔄 Network changed:', chainId);
      location.reload();
    });
  }
}

// Improved auto-connect
window.addEventListener('load', async () => {
  const wasConnected = localStorage.getItem('walletConnected');
  const savedAddress = localStorage.getItem('walletAddress');
  
  if (wasConnected === 'true' && savedAddress && typeof window.ethereum !== 'undefined') {
    setTimeout(async () => {
      try {
        const accounts = await window.ethereum.request({ method: 'eth_accounts' });
        if (accounts.length > 0 && accounts[0].toLowerCase() === savedAddress.toLowerCase()) {
          console.log('🔗 Auto-connecting wallet...');
          await connectWallet();
        } else {
          localStorage.removeItem('walletConnected');
          localStorage.removeItem('walletAddress');
        }
      } catch (error) {
        console.log('Auto-connect failed:', error);
      }
    }, 2000);
  }
  
  // Setup listeners after load
  setupWalletListeners();
});

// Fixed explore function
function exploreSomnia() {
  window.open('https://explorer.somnia.network/address/0xd9145CCE52D386f254917e481eB44e9943F39138?tab=index', '_blank');
}

// Persona Modal Functions
function initializePersonaModal() {
    const options = document.querySelectorAll('.persona-option');
    options.forEach(option => {
        option.addEventListener('click', function() {
            options.forEach(opt => opt.classList.remove('active'));
            this.classList.add('active');
        });
    });
}

window.generatePersona = function() {
    const modal = document.getElementById('personaModal');
    modal.style.display = 'block';
    initializePersonaModal();
}

window.closePersonaModal = function() {
    const modal = document.getElementById('personaModal');
    modal.style.display = 'none';
}

window.startPersonaGeneration = function() {
    const input = document.querySelector('.persona-input');
    const activeOption = document.querySelector('.persona-option.active');
    
    if (input.value.trim() === '') {
        alert('Please describe your desired persona!');
        return;
    }

    const generateBtn = document.querySelector('.modal-btn.generate');
    const originalText = generateBtn.textContent;
    generateBtn.textContent = 'Generating...';
    generateBtn.disabled = true;

    setTimeout(() => {
        alert(`Persona generation started!\nType: ${activeOption.dataset.type}\nDescription: "${input.value}"`);
        closePersonaModal();
        generateBtn.textContent = originalText;
        generateBtn.disabled = false;
        input.value = '';
    }, 2000);
}

window.addEventListener('click', function(event) {
    const modal = document.getElementById('personaModal');
    const isClickInsideModal = modal.contains(event.target);
    const isPersonaBtn = event.target.closest('.portal-btn.creator-btn'); 
    
    if (modal.style.display === 'block' && !isClickInsideModal && !isPersonaBtn) {
        closePersonaModal();
    }
});

// Modal functions
function openModal(data) {
    currentLink = data.link;
    document.getElementById("modalTitle").textContent = data.name;
    document.getElementById("modalDesc").textContent = data.desc;
    modal.classList.add("show");
}

function closeModal() {
    modal.classList.remove("show");
}
</script>
</body>
</html>
